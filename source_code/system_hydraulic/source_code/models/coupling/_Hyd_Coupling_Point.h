#pragma once
/**\class _Hyd_Coupling_Point
	\author Daniel Bachmann et al.
	\author produced by the Institute of Hydraulic Engineering (IWW), RWTH Aachen University
	\version 0.0.1                                                              
	\date 2009 
*/
#ifndef _HYD_COUPLING_POINT_H
#define _HYD_COUPLING_POINT_H

//Class of the coupling partner
class Hyd_Model_Floodplain;


//system_sys_ classes
#include "_Sys_Common_System.h"
#include "Geo_Point.h"


///Structure to store double values in lists
struct _hyd_dicharge_lists{
	///Time [sec]
	QList<double> timepoint;
	///Current discharge [m³/s]
	QList<double> current_discharge;
	///Smoothed discharge [m³/s]
	QList<double> smooth_discharge;
	///Flag if list is relevant
	bool relevant;

};

///Base class for all coupling points representing the interaction between the hydraulic models (e.g. coupling between a river-model to a floodplain-model) \ingroup hyd
/**
The coupling points are generally generated by geometrical interceptions between the models. They store all geometrical information (x-, y- coordinates etc.) 
and the information for evaluation of the flow between the coupled models. This flow represents the interaction between the models
*/
class _Hyd_Coupling_Point : public Geo_Point
{
public:
	///Default constructor
	_Hyd_Coupling_Point(void);
	///Copy constructor
	_Hyd_Coupling_Point(const _Hyd_Coupling_Point& object);
	///Default destructor
	virtual ~_Hyd_Coupling_Point(void);

	//methods
	///Set the point index
	void set_point_index(const int index);
	///Get the point index
	int get_point_index(void);

	///Set distance to the upward point with a given point (upward:=i+1)
	void set_distance_up(_Hyd_Coupling_Point *up_point);
	///Set distance to the upward point with a given distance (upward:=i+1)
	void set_distance_up(const double distance);
	///Get distance to the upward point (upward:=i+1)
	double get_distance_up(void);

	///Set distance to the downward coupling point with a given point (downward:=i-1)
	void set_distance_down(_Hyd_Coupling_Point *down_point);
	///Set distance to the downward point with a given distance (downward:=i-1)
	void set_distance_down(const double distance);
	///Get distance to the downward point (downward:=i-1)
	double get_distance_down(void);

	///Set total distance along the defining polysegment
	void set_total_distance_along_polysegment(const double total_distance);
	///Get total distance along the defining polysegment
	double get_total_distance_along_polysegment(void);

	///Get if a coupling is applied
	bool get_coupling_flag(void);

	///Set the coupling flag
	void set_coupling_flag(const bool flag);

	///Reset the current coupling discharge 
	void reset_coupling_discharge(void);

	///Reset the hydrological balance values and the maximum calculated values
	virtual void reset_hydro_balance_max_values(void);
	///Reset the smoothing calculation members
	virtual void reset_smoothing(void);

	///Get the predicted waterlevel one (FP!)
	double get_predicted_h_one(void);


	///Copy operator
	_Hyd_Coupling_Point& operator=(const _Hyd_Coupling_Point& object);




protected:

	//members
	///Pointindex
	int point_index;
	///Distance to the upwards point along the line (upward:=i+1)
	double distance_up;
	//Distance to the downwards point along the line (downward:=i-1)
	double distance_down;
	///Distance to the start point of the defining polysegement 
	double distance_along_polysegment;
	///This flag defines if a coupling is applied
	bool coupling_flag;

	///Current coupling discharge
	double current_q;
	///The coupling discharge one internal timestep before for smoothing
	double old_q;
	///Stored coupling discharge one internal timestep before for smoothing
	double store_old_q;
	///Velocity of coupling discharges
	double coupling_v;
	///Maximum of the coupling velocity
	_hyd_max_values max_coupling_v;
	///Defines the values for a hydrological balance of this coupling
	_hyd_hydrological_balance coupling_volume;

	///The delta time between old and new time-step
	double delta_t;

	///Constant boundary for the coupling discharge
	const double discharge_boundary;

	///Predicted waterlevel one (FP1)
	double predicted_h_one;
	///Calculated waterlevel one (FP1)
	double calc_h_one;
	///Old calculated waterlvel one (FP1)
	double old_calc_h_one;

	///List of gradients of waterlevel one (FP1)
	QList <double> gradient_list_h_one;
	///Predicted gradient of waterlevel one (FP1)
	double gradient_h_one;

	///Flag if time check or a real step
	bool time_check;

	///Minimal area
	double min_area;





	//method
	///Syncronisation of the coupled models with the couplingspoint
	void syncronisation_coupled_models(void);
	///Calculate the maximum values to a given time point
	void calculate_maximum_values(const double time_point, const double value, _hyd_max_values *max_values);
	///Calculate the hydrological balance of this coupling
	void calculate_hydrological_balance(const double q_current, _hyd_hydrological_balance *balance_value);
	///Smooth the coupling discharge with the coupling discharge calculated one internal timestep before
	virtual double smooth_coupling_discharge(const double q_current, double *old_q);

	///Swap the gradient list
	void swap_grad_list(QList<double> *list, const double new_grad);
	///Replace first of the gradient list
	void replace_first_grad_list(QList<double> *list, const double new_grad);


};
#endif
